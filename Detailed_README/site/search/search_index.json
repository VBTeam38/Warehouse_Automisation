{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Team VB#0038 Team Members: Pratap Kygonahalli, Rithvik G, Shrikar Madhu, Vishisht Rao Summary In this project, we have simulated the Amazon Warehouse environment. The tools we have used are ROS, Gazebo, and RVIZ. The simulation consists of two robotic arms, namely UR5_1 and UR5_2, a shelf consisting of all the packages with different priorities, a conveyor belt, and bins to sort the packages based on how they must be shipped. When an order is placed, the UR5_1 arm picks up the required package from the shelf and places it on the conveyor belt. The conveyor belt takes it to the UR5_2 arm, which sorts the packages to be shipped. Packages with higher priority are picked first. The orders are received using IOT technologies. As the orders are dispatched and shipped in the warehouse, respective emails are sent to the customers informing them of the same. There is also a dashboard which displays the status of packages in real time. Video of Implementation","title":"Introduction"},{"location":"index.html#welcome-to-team-vb0038","text":"Team Members: Pratap Kygonahalli, Rithvik G, Shrikar Madhu, Vishisht Rao","title":"Welcome to Team VB#0038"},{"location":"index.html#summary","text":"In this project, we have simulated the Amazon Warehouse environment. The tools we have used are ROS, Gazebo, and RVIZ. The simulation consists of two robotic arms, namely UR5_1 and UR5_2, a shelf consisting of all the packages with different priorities, a conveyor belt, and bins to sort the packages based on how they must be shipped. When an order is placed, the UR5_1 arm picks up the required package from the shelf and places it on the conveyor belt. The conveyor belt takes it to the UR5_2 arm, which sorts the packages to be shipped. Packages with higher priority are picked first. The orders are received using IOT technologies. As the orders are dispatched and shipped in the warehouse, respective emails are sent to the customers informing them of the same. There is also a dashboard which displays the status of packages in real time.","title":"Summary"},{"location":"index.html#video-of-implementation","text":"","title":"Video of Implementation"},{"location":"api_documentation.html","text":"pkg_task5 Config: Saved Trajectories consists of all the most optimal files of the saved trajectories, which is used for the play function to replay the trajectories. Rviz consists of the .scene files which were used for saving the trajectories to avoid collisions. t5.bag: consists of the recorded bag file of the topics \u2018/eyrc/vb/ur5_1/vacuum_gripper/logical_camera/ur5_1\u2019 and \u2018/eyrc/vb/ur5_2/vacuum_gripper/logical_camera/ur5_2\u2019 which are recorded into the t5.bag file in which all the messages in these topics are saved. task5_solution.launch: files provide us with the capability of launching ROS Master along with our project dependencies at once which running separately is a tedious task. In our case, along with ROS Master, we launch the world in Gazebo, 2 move groups of UR5_1 and UR5_2 in Rviz and the 3 nodes \u2018node_ros_iot_action_bridge.py\u2019, \u2018node_ur5_1.py\u2019 and \u2018node_ur5_2.py\u2019 which controls the individual actions. Also, this is used to record the bag file while the simulation runs in the background. msgDictColours.msg: contains the message file which is used for two purposes. being it transfers the colours dictionary as detected by the camera_1 in between the 2 nodes. Two it will transfer the incoming orders between the nodes for processing of orders to execute them efficiently. node_ur5_1.py: This node contains the working of the UR5_1 arm and any other relevant funcitonalities. Functions send_inventory_to_ur5_2 This function sends the list of incoming orders (a list of dictionaries) to the UR5_2 arm. This is done by publishing this list onto a ROS Topic which is then subscribed to by the node controlling the UR5_2 arm. priority_callback This is the callback function for the subscriber to the ROS Topic which receives the incoming orders from node_action_server_ros_iot_bridge.py These incoming orders are stored as a list of dictionaries (each dictionary containing information about a single order). A goal is then sent to the Action Server, which then leads to the relevant spreadsheet being updated. on_transition This function is called when there is a change of state in the Action Client. That is, when the processing of a goal has started, or on the completion of a goal, this function is invoked. The relevant success/failure information is then printed to the console. got_the_colours This is the callback function for the subscriber to the ROS Topic which receives the inventory (details about each package on the shelf) as a dictionary from node_ur5_2.py as node_ur5_2.py publishes this information onto the relevant ROS Topic. service_activate_deactivate This function makes a ROS Service call to activate/deactivate the vacuum gripper. service_start_stop This function makes a ROS Service call to start/stop the conveyor belt. moveit_play_planned_path_from_file This function plays tractories stored in the YAML files. moveit_hard_play_planned_path_from_file This acts as a wrapper function for moveit_play_planned_path_from_file and calls this function until it is successful. pick_it_and_put_it This function executes a series of instructions which prompts the UR5_1 arm to go to a particular package on the shelf, pick it up, go to the conveyor belt, and drop it. set_joint_angles This function moves the UR5_1 arm to a particular set of joint angles. hard_set_joint_angles This function acts as a wrapper function for set_joint_angles and calls this function until it is successful. Working the conveyor belt is started and the UR5_1 arm is moved to the drop position (position where it drops packages onto the conveyor belt). Then an infinite loop is constructed which continuously checks if all the incoming orders have been processed. The list of incoming orders is first sorted based on priority, then the one with the highest priority is processed, by executing the pick_it_and_put_it function for that particular package. Then the list is updated to remove the processed order. As each package is dispatched, a goal is sent to the Action Server which then leads to the relevant spreadsheet being updated. node_ur5_2.py: node is used to control the ur5_2 arm, camera_1, priority ordering of orders, logical_camera and IOT based operations. To start off, we subscribe to \u2018/ur5_1_to_ur5_2/inventory\u2019 and \u2018/eyrc/vb/logical_camera_2\u2019 who subscribes to msgDictColours and LogicalCameraImage msgs respectively which is used to transfer the information between nodes. The initialisation is done with all the private variables which define the topic, publisher, subscribers, listener, home_pose, and other flag variables to indicate the competition of tasks. callback function is used to read the input of camera_1 which uses OpenCV to analyse the image. The input image is resized and segmented and the given as an input to the get_dominant_colour function. The get_dominant colour function is used to identify the most prominent colour in the input image. By using mean colours for values of blue, green and red. All these colours are then stored in a dict() for sending to the Google Spreadsheet and as a message to the other node. The orders received through the MQTT Topic are processed by the priority_callback function to append to a list to queue the orders for processing based on priority listing. The hard_set_joint_angles function is an extension of the set_joint_angles function which basically sets the joint angles of the UR5 arm without failing to do so because we give it multiple attempts to set it. service_start_stop is used to control the movement of the conveyor belt based on the power level. The service_activate_deactivate is used to control the vacuum gripper of the UR5 arm to grasp the package from the shelf and drop it in the bin OR pick it up from the conveyor and drop it into the bin. The pick_place_start function starts the operation of picking up the packages into the bin and place it into the conveyor and simultaneously update the dispatched/shipped flags onto the Spreadsheet and the completion flags in the program. The camera_callback is the callback function for the logical_camera which gets the package name, ex. \u2018packagen00\u2019 which helps to update the completion flags. The destructor is used to delete the class after the program objective has been completed. pkg_ros_iot_bridge msgRosIot.action: is the action file which contains a protocol, mode, topic, message as a goal. It is through this goal that node_ur5_1.py and node_ur5_2.py prompt node_action_server_ros_iot_bridge.py to update relevant information to spreadsheets. config_pyiot.yaml: is a config file that stores certain constants such as topic names, spreadsheet IDs, etc. msgMqttSub.msg: is a message file that contains timestamp, topic, and message. It is over this message file that node_action_server_ros_iot_bridge.py send the incoming orders. The topic is subscribed by node_ur5_1.py. node_action_server_ros_iot_bridge.py: node performs all ROS-IOT communications. Functions mqtt_sub_callback This is the callback function for when the MQTT Topic receives a message. This message is then sent over a ROS Topic to be accessed by node_ur5_1.py. on_goal This function is called when the Action Server receives a goal (sent either by node_ur5_1.py or node_ur5_2.py to update to spreadsheet). This validates the goal and then starts a thread to process it. process_goal When on_goal starts a thread to process a goal, this function is called. This function gets the goal and invokes the data_to_sheet function to update the spreadsheets. on_cancel This function is called when goal cancel request is sent to the action server. data_to_sheet This function updates the required spreadsheet depending on the value sent through the goal. It calculates all the required parameters and then sends it to the spreadsheet by performing a HTTP GET request. Working node performs all ROS-IOT communications. It receives incoming orders through the MQTT Topic and sends it over a ROS Topic to other nodes. It receives goals through action messages, send by other nodes, and processes these goals by updating relevant values onto the correct spreadsheets. pkg_task5 Tree pkg_ros_iot_bridge Tree","title":"API Documentation"},{"location":"api_documentation.html#pkg_task5","text":"","title":"pkg_task5"},{"location":"api_documentation.html#config","text":"Saved Trajectories consists of all the most optimal files of the saved trajectories, which is used for the play function to replay the trajectories. Rviz consists of the .scene files which were used for saving the trajectories to avoid collisions.","title":"Config:"},{"location":"api_documentation.html#t5bag","text":"consists of the recorded bag file of the topics \u2018/eyrc/vb/ur5_1/vacuum_gripper/logical_camera/ur5_1\u2019 and \u2018/eyrc/vb/ur5_2/vacuum_gripper/logical_camera/ur5_2\u2019 which are recorded into the t5.bag file in which all the messages in these topics are saved.","title":"t5.bag:"},{"location":"api_documentation.html#task5_solutionlaunch","text":"files provide us with the capability of launching ROS Master along with our project dependencies at once which running separately is a tedious task. In our case, along with ROS Master, we launch the world in Gazebo, 2 move groups of UR5_1 and UR5_2 in Rviz and the 3 nodes \u2018node_ros_iot_action_bridge.py\u2019, \u2018node_ur5_1.py\u2019 and \u2018node_ur5_2.py\u2019 which controls the individual actions. Also, this is used to record the bag file while the simulation runs in the background.","title":"task5_solution.launch:"},{"location":"api_documentation.html#msgdictcoloursmsg","text":"contains the message file which is used for two purposes. being it transfers the colours dictionary as detected by the camera_1 in between the 2 nodes. Two it will transfer the incoming orders between the nodes for processing of orders to execute them efficiently.","title":"msgDictColours.msg:"},{"location":"api_documentation.html#node_ur5_1py","text":"This node contains the working of the UR5_1 arm and any other relevant funcitonalities.","title":"node_ur5_1.py:"},{"location":"api_documentation.html#functions","text":"send_inventory_to_ur5_2 This function sends the list of incoming orders (a list of dictionaries) to the UR5_2 arm. This is done by publishing this list onto a ROS Topic which is then subscribed to by the node controlling the UR5_2 arm. priority_callback This is the callback function for the subscriber to the ROS Topic which receives the incoming orders from node_action_server_ros_iot_bridge.py These incoming orders are stored as a list of dictionaries (each dictionary containing information about a single order). A goal is then sent to the Action Server, which then leads to the relevant spreadsheet being updated. on_transition This function is called when there is a change of state in the Action Client. That is, when the processing of a goal has started, or on the completion of a goal, this function is invoked. The relevant success/failure information is then printed to the console. got_the_colours This is the callback function for the subscriber to the ROS Topic which receives the inventory (details about each package on the shelf) as a dictionary from node_ur5_2.py as node_ur5_2.py publishes this information onto the relevant ROS Topic. service_activate_deactivate This function makes a ROS Service call to activate/deactivate the vacuum gripper. service_start_stop This function makes a ROS Service call to start/stop the conveyor belt. moveit_play_planned_path_from_file This function plays tractories stored in the YAML files. moveit_hard_play_planned_path_from_file This acts as a wrapper function for moveit_play_planned_path_from_file and calls this function until it is successful. pick_it_and_put_it This function executes a series of instructions which prompts the UR5_1 arm to go to a particular package on the shelf, pick it up, go to the conveyor belt, and drop it. set_joint_angles This function moves the UR5_1 arm to a particular set of joint angles. hard_set_joint_angles This function acts as a wrapper function for set_joint_angles and calls this function until it is successful.","title":"Functions"},{"location":"api_documentation.html#working","text":"the conveyor belt is started and the UR5_1 arm is moved to the drop position (position where it drops packages onto the conveyor belt). Then an infinite loop is constructed which continuously checks if all the incoming orders have been processed. The list of incoming orders is first sorted based on priority, then the one with the highest priority is processed, by executing the pick_it_and_put_it function for that particular package. Then the list is updated to remove the processed order. As each package is dispatched, a goal is sent to the Action Server which then leads to the relevant spreadsheet being updated.","title":"Working"},{"location":"api_documentation.html#node_ur5_2py","text":"node is used to control the ur5_2 arm, camera_1, priority ordering of orders, logical_camera and IOT based operations. To start off, we subscribe to \u2018/ur5_1_to_ur5_2/inventory\u2019 and \u2018/eyrc/vb/logical_camera_2\u2019 who subscribes to msgDictColours and LogicalCameraImage msgs respectively which is used to transfer the information between nodes. The initialisation is done with all the private variables which define the topic, publisher, subscribers, listener, home_pose, and other flag variables to indicate the competition of tasks. callback function is used to read the input of camera_1 which uses OpenCV to analyse the image. The input image is resized and segmented and the given as an input to the get_dominant_colour function. The get_dominant colour function is used to identify the most prominent colour in the input image. By using mean colours for values of blue, green and red. All these colours are then stored in a dict() for sending to the Google Spreadsheet and as a message to the other node. The orders received through the MQTT Topic are processed by the priority_callback function to append to a list to queue the orders for processing based on priority listing. The hard_set_joint_angles function is an extension of the set_joint_angles function which basically sets the joint angles of the UR5 arm without failing to do so because we give it multiple attempts to set it. service_start_stop is used to control the movement of the conveyor belt based on the power level. The service_activate_deactivate is used to control the vacuum gripper of the UR5 arm to grasp the package from the shelf and drop it in the bin OR pick it up from the conveyor and drop it into the bin. The pick_place_start function starts the operation of picking up the packages into the bin and place it into the conveyor and simultaneously update the dispatched/shipped flags onto the Spreadsheet and the completion flags in the program. The camera_callback is the callback function for the logical_camera which gets the package name, ex. \u2018packagen00\u2019 which helps to update the completion flags. The destructor is used to delete the class after the program objective has been completed.","title":"node_ur5_2.py:"},{"location":"api_documentation.html#pkg_ros_iot_bridge","text":"","title":"pkg_ros_iot_bridge"},{"location":"api_documentation.html#msgrosiotaction","text":"is the action file which contains a protocol, mode, topic, message as a goal. It is through this goal that node_ur5_1.py and node_ur5_2.py prompt node_action_server_ros_iot_bridge.py to update relevant information to spreadsheets.","title":"msgRosIot.action:"},{"location":"api_documentation.html#config_pyiotyaml","text":"is a config file that stores certain constants such as topic names, spreadsheet IDs, etc.","title":"config_pyiot.yaml:"},{"location":"api_documentation.html#msgmqttsubmsg","text":"is a message file that contains timestamp, topic, and message. It is over this message file that node_action_server_ros_iot_bridge.py send the incoming orders. The topic is subscribed by node_ur5_1.py.","title":"msgMqttSub.msg:"},{"location":"api_documentation.html#node_action_server_ros_iot_bridgepy","text":"node performs all ROS-IOT communications.","title":"node_action_server_ros_iot_bridge.py:"},{"location":"api_documentation.html#functions_1","text":"mqtt_sub_callback This is the callback function for when the MQTT Topic receives a message. This message is then sent over a ROS Topic to be accessed by node_ur5_1.py. on_goal This function is called when the Action Server receives a goal (sent either by node_ur5_1.py or node_ur5_2.py to update to spreadsheet). This validates the goal and then starts a thread to process it. process_goal When on_goal starts a thread to process a goal, this function is called. This function gets the goal and invokes the data_to_sheet function to update the spreadsheets. on_cancel This function is called when goal cancel request is sent to the action server. data_to_sheet This function updates the required spreadsheet depending on the value sent through the goal. It calculates all the required parameters and then sends it to the spreadsheet by performing a HTTP GET request.","title":"Functions"},{"location":"api_documentation.html#working_1","text":"node performs all ROS-IOT communications. It receives incoming orders through the MQTT Topic and sends it over a ROS Topic to other nodes. It receives goals through action messages, send by other nodes, and processes these goals by updating relevant values onto the correct spreadsheets.","title":"Working"},{"location":"api_documentation.html#pkg_task5-tree","text":"","title":"pkg_task5 Tree"},{"location":"api_documentation.html#pkg_ros_iot_bridge-tree","text":"","title":"pkg_ros_iot_bridge Tree"},{"location":"implementation.html","text":"Detailed Description of Implementation Environment We have a gazebo simulation environment of an Amazon Warehouse. In this warehouse we have the following objects: Two UR5 robotic arms named UR5#1 and UR5#2 Two Logical Cameras named Logical Camera#1 and Logical Camera#2 Packages of high, low and medium priority Shelf which consists of the packages A 2D camera to detect the colours of the packages Conveyor belt to transport packages from one part of the warehouse to another Sorting bins for high, medium and low priority packages Working Camera_1: camera_1 is used to identify the colours of the boxes in the individual shelves for the arm to go and pick up. The camera gives the feed of the entire shelf with all the packages in frame. Since it is not possible to identify the colours of the packages in one entire frame, we have segmented each of the boxes into its own separate image, which enables us to detect the colour by identifying the most dominant colour in the segment of the picture. This is then stored into the dictionary which then used in multiple parts of the upcoming program. The dictionary is published onto the Spreadsheet using the ROS-IOT Bridge to the \u201cinventory\u201d sheet. This is also used to map the colours to the trajectory files for the movement of the UR5#1 arm. Receiving Incoming Orders: 1 minute of Simulation Time in Gazebo, a total of 9 orders are published onto the topic /eyrs/vb/RrSsVvPp/orders MQTT Topic at different intervals for each order. The yaml parameter file config_online_order.yaml is used to publish onto the MQTT Topic. We subscribe to this topic through our python code and every incoming order (in the form of a dictionary) is stored as an element of a list. This list is then published to a ROS Topic so that all our running nodes have access to this list. Save and Play: ! saves the trajectories planned by the Planner (TrakIK Kinematics Planner) selected during the moveit_setup_assistant into a YAML File and then use it whenever you want. This is advantageous to us because you can save time by saving time off the planner by replaying the data stored in the YAML File. giving the Planner sufficient amount of time to plan and sufficient number of attempts in the case of any controller failure or inability to plan a trajectory, we have taken 10 trials for each package on the shelf to and from the dropPose above the conveyor that amounts to around 240 files out of which some are null because it failed to save the trajectory. After an analysis of each of the files to find the most optimal trajectory for that package. All of the optimal files are placed inside the \"pkg\"/config/saved_trajectories/ which are then accessed by the play function to replay the trajectory. UR5#1 Arm: robot arm is used to pick up packages from the shelf and put them on the conveyor belt. Through the knowledge of the sorted list of incoming orders, it picks up the package with the highest priority. have used save and play for the locations of all the packages on the shelf. Conveyor: mentioned earlier, we have two UR5 arms, one to pick up packages from the shelf and drop them onto the conveyor belt(UR5#1) and one to pick up packages from the conveyor belt and sort them into the correct bins (UR5#2). conveyor belt is initially switched on at the maximum speed, and packages are dropped onto the moving conveyor belt by UR5#1. The conveyor belt then takes these packages to UR5#2. When the packages near UR5#2, the convyor belt is stopped to ensure the smooth pick up of the packages from the conveyor belt by the UR5#2 arm. After a package has been picked up, the conveyor belt is restarted at the maximum speed. Logical Camera: camera is used to determine the package number, ex. \u2018packagen00\u2019 which is then stored into the dictionary and the used to update the Google SpreadSheet for dispatched and shipped updates. UR5#2 Arm: UR5#2 arm is used to pick the package from the conveyor and place the package in its identical coloured bin. Updating Spreadsheets: update a total of five spreadsheets in real time to make data management and visualization easy. These five spreadhseets are: Inventory Incoming Orders Orders Dispatched Orders Shipped Dashboard Inventory This sheet contains details of all 12 packags on the shelf, as identified by Camera#1. Incoming Orders This sheet contains details about the incoming orders, which is a list of dictionaries as explained above. Orders Dispatched This sheet is updated with details about each order once it has been dispatched, i.e. when UR5#1 drops the package oto the conveyor belt. Orders Shipped This sheet is updated with details about each order once it has been shipped, i.e. when UR5#2 successfully sorts the package into the correct bin. Dashboard sheet contains a compilation of data from the above spreadhsheets and keeps track of the status of each order. The dashboard webpage also sources its data from this spreadsheet. an order has been dispatched or shipped (i.e. a package has been dropped onto the conveyor belt or sorted into a bin), a goal is sent to an Action Server containing a dictionary filled with details about the package that has been dispatched or shipped. The node which communicates between ROS and IOT then subscribes to this Action message, which prompts it to update the correct spreadhsheet with the relevant information. Google Apps Scripting: a HTTP GET request is sent from the nodes (python file), the columns and rows get updated automatically through the google app script code of the spreadsheets. values for all columns in the spreadsheet are recieved as parameters in the HTTP request by the node. Email: an order gets shipped or dispatched a mail is sent to the customer with details about the shipped or dispatched package. Dashboard: shows the status of the orders in real-time The dashboard consists of 3 parts: Geolocation(map) showing information about Inventory order Table showing the live status of the orders Graph showing the status of time taken for each order a package is shipped the table gets updated with the following information: Order ID Item Priority Quantity City Dispatched Shipped Order Date and Time Dispatch Date and Time Shipping Date and Time Time Taken red marker is put on the map when an order is placed at a certain location. When the order gets dispatched the marker changes to yellow colour and after the order is shipped the marker colour changes to green. dashboard is updated in real time i.e. every time an order is shipped or dispatched the table, map and graph are updated. Dashboard Light Mode Dashboard Dark Mode","title":"Implementation"},{"location":"implementation.html#detailed-description-of-implementation","text":"","title":"Detailed Description of Implementation"},{"location":"implementation.html#environment","text":"We have a gazebo simulation environment of an Amazon Warehouse. In this warehouse we have the following objects: Two UR5 robotic arms named UR5#1 and UR5#2 Two Logical Cameras named Logical Camera#1 and Logical Camera#2 Packages of high, low and medium priority Shelf which consists of the packages A 2D camera to detect the colours of the packages Conveyor belt to transport packages from one part of the warehouse to another Sorting bins for high, medium and low priority packages","title":"Environment"},{"location":"implementation.html#working","text":"","title":"Working"},{"location":"implementation.html#camera_1","text":"camera_1 is used to identify the colours of the boxes in the individual shelves for the arm to go and pick up. The camera gives the feed of the entire shelf with all the packages in frame. Since it is not possible to identify the colours of the packages in one entire frame, we have segmented each of the boxes into its own separate image, which enables us to detect the colour by identifying the most dominant colour in the segment of the picture. This is then stored into the dictionary which then used in multiple parts of the upcoming program. The dictionary is published onto the Spreadsheet using the ROS-IOT Bridge to the \u201cinventory\u201d sheet. This is also used to map the colours to the trajectory files for the movement of the UR5#1 arm.","title":"Camera_1:"},{"location":"implementation.html#receiving-incoming-orders","text":"1 minute of Simulation Time in Gazebo, a total of 9 orders are published onto the topic /eyrs/vb/RrSsVvPp/orders MQTT Topic at different intervals for each order. The yaml parameter file config_online_order.yaml is used to publish onto the MQTT Topic. We subscribe to this topic through our python code and every incoming order (in the form of a dictionary) is stored as an element of a list. This list is then published to a ROS Topic so that all our running nodes have access to this list.","title":"Receiving Incoming Orders:"},{"location":"implementation.html#save-and-play","text":"! saves the trajectories planned by the Planner (TrakIK Kinematics Planner) selected during the moveit_setup_assistant into a YAML File and then use it whenever you want. This is advantageous to us because you can save time by saving time off the planner by replaying the data stored in the YAML File. giving the Planner sufficient amount of time to plan and sufficient number of attempts in the case of any controller failure or inability to plan a trajectory, we have taken 10 trials for each package on the shelf to and from the dropPose above the conveyor that amounts to around 240 files out of which some are null because it failed to save the trajectory. After an analysis of each of the files to find the most optimal trajectory for that package. All of the optimal files are placed inside the \"pkg\"/config/saved_trajectories/ which are then accessed by the play function to replay the trajectory.","title":"Save and Play:"},{"location":"implementation.html#ur51-arm","text":"robot arm is used to pick up packages from the shelf and put them on the conveyor belt. Through the knowledge of the sorted list of incoming orders, it picks up the package with the highest priority. have used save and play for the locations of all the packages on the shelf.","title":"UR5#1 Arm:"},{"location":"implementation.html#conveyor","text":"mentioned earlier, we have two UR5 arms, one to pick up packages from the shelf and drop them onto the conveyor belt(UR5#1) and one to pick up packages from the conveyor belt and sort them into the correct bins (UR5#2). conveyor belt is initially switched on at the maximum speed, and packages are dropped onto the moving conveyor belt by UR5#1. The conveyor belt then takes these packages to UR5#2. When the packages near UR5#2, the convyor belt is stopped to ensure the smooth pick up of the packages from the conveyor belt by the UR5#2 arm. After a package has been picked up, the conveyor belt is restarted at the maximum speed.","title":"Conveyor:"},{"location":"implementation.html#logical-camera","text":"camera is used to determine the package number, ex. \u2018packagen00\u2019 which is then stored into the dictionary and the used to update the Google SpreadSheet for dispatched and shipped updates.","title":"Logical Camera:"},{"location":"implementation.html#ur52-arm","text":"UR5#2 arm is used to pick the package from the conveyor and place the package in its identical coloured bin.","title":"UR5#2 Arm:"},{"location":"implementation.html#updating-spreadsheets","text":"update a total of five spreadsheets in real time to make data management and visualization easy. These five spreadhseets are: Inventory Incoming Orders Orders Dispatched Orders Shipped Dashboard Inventory This sheet contains details of all 12 packags on the shelf, as identified by Camera#1. Incoming Orders This sheet contains details about the incoming orders, which is a list of dictionaries as explained above. Orders Dispatched This sheet is updated with details about each order once it has been dispatched, i.e. when UR5#1 drops the package oto the conveyor belt. Orders Shipped This sheet is updated with details about each order once it has been shipped, i.e. when UR5#2 successfully sorts the package into the correct bin. Dashboard sheet contains a compilation of data from the above spreadhsheets and keeps track of the status of each order. The dashboard webpage also sources its data from this spreadsheet. an order has been dispatched or shipped (i.e. a package has been dropped onto the conveyor belt or sorted into a bin), a goal is sent to an Action Server containing a dictionary filled with details about the package that has been dispatched or shipped. The node which communicates between ROS and IOT then subscribes to this Action message, which prompts it to update the correct spreadhsheet with the relevant information.","title":"Updating Spreadsheets:"},{"location":"implementation.html#google-apps-scripting","text":"a HTTP GET request is sent from the nodes (python file), the columns and rows get updated automatically through the google app script code of the spreadsheets. values for all columns in the spreadsheet are recieved as parameters in the HTTP request by the node.","title":"Google Apps Scripting:"},{"location":"implementation.html#email","text":"an order gets shipped or dispatched a mail is sent to the customer with details about the shipped or dispatched package.","title":"Email:"},{"location":"implementation.html#dashboard","text":"shows the status of the orders in real-time The dashboard consists of 3 parts: Geolocation(map) showing information about Inventory order Table showing the live status of the orders Graph showing the status of time taken for each order a package is shipped the table gets updated with the following information: Order ID Item Priority Quantity City Dispatched Shipped Order Date and Time Dispatch Date and Time Shipping Date and Time Time Taken red marker is put on the map when an order is placed at a certain location. When the order gets dispatched the marker changes to yellow colour and after the order is shipped the marker colour changes to green. dashboard is updated in real time i.e. every time an order is shipped or dispatched the table, map and graph are updated.","title":"Dashboard:"},{"location":"implementation.html#dashboard-light-mode","text":"","title":"Dashboard Light Mode"},{"location":"implementation.html#dashboard-dark-mode","text":"","title":"Dashboard Dark Mode"}]}